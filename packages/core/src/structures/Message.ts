import type {
  APIMessage,
  RESTPatchAPIChannelMessageJSONBody,
  RESTPostAPIChannelMessageJSONBody,
  MessageReferenceType,
} from "discord-api-types/v10";
import type { Client } from "@/Client.ts";

/**
 * Represents a Discord message.
 */
export class Message {
  private client: Client;
  private data: APIMessage;

  constructor(client: Client, data: APIMessage) {
    this.client = client;
    this.data = data;
  }

  /**
   * ID of the message
   */
  get id() {
    return this.data.id;
  }

  /**
   * ID of the channel the message was sent in
   */
  get channel_id() {
    return this.data.channel_id;
  }

  /**
   * The author of this message (as a User structure)
   */
  get author() {
    let user = this.client.users.get(this.data.author.id);

    if (!user) {
      user = this.client.users._addFromData(this.data.author);
    }
    return user;
  }

  /**
   * Contents of the message
   */
  get content() {
    return this.data.content;
  }

  /**
   * When this message was sent
   */
  get timestamp() {
    return this.data.timestamp;
  }

  /**
   * When this message was edited (or null if never)
   */
  get edited_timestamp() {
    return this.data.edited_timestamp;
  }

  /**
   * Whether this was a TTS message
   */
  get tts() {
    return this.data.tts;
  }

  /**
   * Whether this message mentions everyone
   */
  get mention_everyone() {
    return this.data.mention_everyone;
  }

  /**
   * Users specifically mentioned in the message
   */
  get mentions() {
    return this.data.mentions;
  }

  /**
   * Roles specifically mentioned in this message
   */
  get mention_roles() {
    return this.data.mention_roles;
  }

  /**
   * Channels specifically mentioned in this message
   */
  get mention_channels() {
    return this.data.mention_channels;
  }

  /**
   * Any attached files
   */
  get attachments() {
    return this.data.attachments;
  }

  /**
   * Any embedded content
   */
  get embeds() {
    return this.data.embeds;
  }

  /**
   * Reactions to the message
   */
  get reactions() {
    return this.data.reactions;
  }

  /**
   * A nonce that can be used for optimistic message sending
   */
  get nonce() {
    return this.data.nonce;
  }

  /**
   * Whether this message is pinned
   */
  get pinned() {
    return this.data.pinned;
  }

  /**
   * If the message is generated by a webhook, this is the webhook's id
   */
  get webhook_id() {
    return this.data.webhook_id;
  }

  /**
   * Type of message
   */
  get type() {
    return this.data.type;
  }

  /**
   * Sent with Rich Presence-related chat embeds
   */
  get activity() {
    return this.data.activity;
  }

  /**
   * Sent with Rich Presence-related chat embeds
   */
  get application() {
    return this.data.application;
  }

  /**
   * If the message is a response to an Interaction, this is the id of the interaction's application
   */
  get application_id() {
    return this.data.application_id;
  }

  /**
   * Reference data sent with crossposted messages, replies, pins, and thread starter messages
   */
  get message_reference() {
    return this.data.message_reference;
  }

  /**
   * Message flags combined as a bitfield
   */
  get flags() {
    return this.data.flags;
  }

  /**
   * The message associated with the message_reference
   */
  get referenced_message() {
    return this.data.referenced_message;
  }

  /**
   * Sent if the message is sent as a result of an interaction
   */
  get interaction_metadata() {
    return this.data.interaction_metadata;
  }

  /**
   * Sent if the message is a response to an Interaction
   * @deprecated In favor of interaction_metadata
   */
  get interaction() {
    return this.data.interaction;
  }

  /**
   * Sent if a thread was started from this message
   */
  get thread() {
    return this.data.thread;
  }

  /**
   * Sent if the message contains components like buttons, action rows, or other interactive components
   */
  get components() {
    return this.data.components;
  }

  /**
   * Sent if the message contains stickers
   */
  get sticker_items() {
    return this.data.sticker_items;
  }

  /**
   * The stickers sent with the message
   * @deprecated Use sticker_items instead
   */
  get stickers() {
    return this.data.stickers;
  }

  /**
   * A generally increasing integer that represents the approximate position of the message in a thread
   */
  get position() {
    return this.data.position;
  }

  /**
   * Data of the role subscription purchase or renewal
   */
  get role_subscription_data() {
    return this.data.role_subscription_data;
  }

  /**
   * Data for users, members, channels, and roles in the message's auto-populated select menus
   */
  get resolved() {
    return this.data.resolved;
  }

  /**
   * A poll
   */
  get poll() {
    return this.data.poll;
  }

  /**
   * The message snapshots (for forwarded messages)
   */
  get message_snapshots() {
    return this.data.message_snapshots;
  }

  /**
   * The call associated with the message
   */
  get call() {
    return this.data.call;
  }

  /**
   * Reply to this message.
   * @param data - The message data
   */
  reply = async (data: RESTPostAPIChannelMessageJSONBody): Promise<Message> => {
    const payload: RESTPostAPIChannelMessageJSONBody = {
      ...data,
      message_reference: {
        message_id: this.data.id,
        channel_id: this.data.channel_id,
      },
    };

    const response = await this.client.rest.post<APIMessage>(`/channels/${this.data.channel_id}/messages`, {
      body: payload,
    });

    return new Message(this.client, response);
  };

  /**
   * Edit this message.
   * @param data - The data to update the message with
   */
  edit = async (data: RESTPatchAPIChannelMessageJSONBody): Promise<Message> => {
    const updated = await this.client.rest.patch<APIMessage>(`/channels/${this.data.channel_id}/messages/${this.data.id}`, {
      body: data,
    });
    this.data = updated;
    return this;
  };

  /**
   * Delete this message.
   * @param reason - The reason for deleting the message (for audit log)
   */
  delete = async (reason?: string): Promise<void> => {
    await this.client.rest.delete(`/channels/${this.data.channel_id}/messages/${this.data.id}`, { reason });
  };

  /**
   * Forward this message to another channel.
   * @param channel_id - The ID of the channel to forward the message to
   */
  forward = async (channel_id: string): Promise<Message> => {
    const payload: RESTPostAPIChannelMessageJSONBody = {
      message_reference: {
        type: 1 as MessageReferenceType.Forward,
        message_id: this.data.id,
        channel_id: this.data.channel_id,
      },
    };

    const response = await this.client.rest.post<APIMessage>(`/channels/${channel_id}/messages`, {
      body: payload,
    });

    return new Message(this.client, response);
  };

  /**
   * Pin this message.
   * @param reason - The reason for pinning the message (for audit log)
   */
  pin = async (reason?: string): Promise<void> => {
    await this.client.rest.put(`/channels/${this.data.channel_id}/pins/${this.data.id}`, { reason });
  };

  /**
   * Unpin this message.
   * @param reason - The reason for unpinning the message (for audit log)
   */
  unpin = async (reason?: string): Promise<void> => {
    await this.client.rest.delete(`/channels/${this.data.channel_id}/pins/${this.data.id}`, { reason });
  };

  /**
   * Add a reaction to this message.
   * @param emoji - The emoji to react with (format: name:id for custom emoji, or unicode emoji)
   */
  react = async (emoji: string): Promise<void> => {
    await this.client.rest.put(`/channels/${this.data.channel_id}/messages/${this.data.id}/reactions/${encodeURIComponent(emoji)}/@me`);
  };

  /**
   * Remove a reaction from this message.
   * @param emoji - The emoji to remove (format: name:id for custom emoji, or unicode emoji)
   * @param user_id - The ID of the user whose reaction to remove (defaults to @me)
   */
  unreact = async (emoji: string, user_id: string = "@me"): Promise<void> => {
    await this.client.rest.delete(`/channels/${this.data.channel_id}/messages/${this.data.id}/reactions/${encodeURIComponent(emoji)}/${user_id}`);
  };

  /**
   * Crosspost this message to following channels (announcement channels only).
   */
  crosspost = async (): Promise<Message> => {
    const crossposted = await this.client.rest.post<APIMessage>(`/channels/${this.data.channel_id}/messages/${this.data.id}/crosspost`);
    this.data = crossposted;
    return this;
  };

  /**
   * Fetch the channel this message belongs to.
   */
  fetchChannel = async () => {
    return await this.client.channels.fetch(this.data.channel_id);
  };

  /**
   * Get the channel from cache.
   * Returns the channel as a text-based channel type since messages can only come from text channels.
   * The channel is guaranteed to be cached by the MESSAGE_CREATE handler.
   */
  get channel() {
    const channel = this.client.channels.get(this.data.channel_id);

    if (channel && channel.isTextBased()) {
      return channel as import("./channels/TextBasedChannel.ts").TextBasedChannel;
    }

    return channel!;
  }

  /**
   * Fetch the guild this message belongs to (if in a guild channel).
   */
  fetchGuild = async () => {
    const guild_id = "guild_id" in this.data ? this.data.guild_id : undefined;
    if (!guild_id) return null;
    return await this.client.guilds.fetch(guild_id as string);
  };

  /**
   * Get the guild from cache if available (if in a guild channel).
   */
  get guild() {
    const guild_id = "guild_id" in this.data ? this.data.guild_id : undefined;
    if (!guild_id) return null;
    return this.client.guilds.get(guild_id as string) ?? null;
  }

  /**
   * Get the member from cache if available (if in a guild channel).
   * This will be undefined if the message is not in a guild or the member isn't cached.
   */
  get member() {
    const guild = this.guild;
    if (!guild) return undefined;
    return guild.members.get(this.data.author.id);
  }

  /**
   * Get the raw API data.
   */
  toJSON = (): APIMessage => {
    return this.data;
  };
}
